use std.io
use std.array
use lexer

alias Expr_Kind int
const (
   EXPR_SYM
   EXPR_FUN
   COUNT_EXPRS
)

struct Expr {
   kind Expr_Kind
   name Str
   args *char # *Expr
   args_count int
   args_capacity int
} 

fn expr_sym(name Str) Expr {
   let expr Expr
   expr.kind = EXPR_SYM
   expr.name = name
   return expr
}

fn expr_fun(name Str) Expr {
   let expr Expr
   expr.kind = EXPR_FUN
   expr.name = name
   expr.args = 0 as *char
   expr.args_count = 0
   expr.args_capacity = 0
   return expr
}

assert COUNT_EXPRS == 2
fn [==](a Expr, b Expr) bool {
   if a.name != b.name {
      return false
   }
   if a.kind == EXPR_FUN && b.kind == EXPR_FUN {
      if a.args_count != b.args_count {
         return false
      }
      for let i = 0, i < a.args_count, i += 1 {
         if !((a.args as *Expr)[i] == (b.args as *Expr)[i]) {
            return false
         }
      }
   }
   return true
}

fn [<<](fun *Expr, arg Expr) *Expr {
   assert fun.kind == EXPR_FUN
   *(array_push(&fun.args, &fun.args_count, &fun.args_capacity, sizeof(Expr)) as *Expr) = arg
   return fun
}

fn [<<](fun Expr, arg Expr) Expr {
   return *(&fun << arg)
}

assert COUNT_EXPRS == 2
fn [<<](file *File, expr Expr) *File {
   match expr.kind {
      EXPR_SYM => file << expr.name
      EXPR_FUN => {
         file << expr.name << "("
         for let i = 0, i < expr.args_count, i += 1 {
            if i > 0 { file << ", " }
            file << (expr.args as *Expr)[i]
         }
         file << ")"
      }
   }
   return file
}

struct Binding {
   name Str
   value Expr
}

struct Bindings {
   data *Binding
   count int
   capacity int
}

fn bindings_find(bindings *Bindings, name Str, value *Expr) bool {
   for let i = 0, i < bindings.count, i += 1 {
      if bindings.data[i].name == name {
         *value = bindings.data[i].value
         return true
      }
   }
   return false
}

assert COUNT_EXPRS == 2
fn bindings_substitute(bindings *Bindings, expr Expr) Expr {
   match expr.kind {
      EXPR_SYM => {
         let value Expr
         if bindings_find(bindings, expr.name, &value) {
            return value
         }
         return expr
      }
      EXPR_FUN => {
         let new_name Str
         let value Expr
         if bindings_find(bindings, expr.name, &value) {
            if value.kind != EXPR_SYM {
               &stderr << "error: expected symbol in the place of the functor name\n"
               exit(1)
            }
            new_name = value.name
         } else {
            new_name = expr.name
         }
         let new_fun = expr_fun(new_name)
         for let i = 0, i < expr.args_count, i += 1 {
            &new_fun << bindings_substitute(bindings, (expr.args as *Expr)[i])
         }
         return new_fun
      }
   }
   assert false
   return expr
}

fn [<<](file *File, bindings Bindings) *File {
   for let i = 0, i < bindings.count, i += 1 {
      file << bindings.data[i].name << " -> " << bindings.data[i].value
      if i < bindings.count - 1 { file << "\n" }
   }
   return file
}

assert COUNT_EXPRS == 2
fn pattern_match(pattern Expr, value Expr, bindings *Bindings) bool {
   if pattern.kind == EXPR_SYM {
      let bound_value Expr
      if bindings_find(bindings, pattern.name, &bound_value) {
         return bound_value == value
      } else {
         let binding Binding
         binding.name = pattern.name
         binding.value = value
         *(array_push(&bindings.data as **char, &bindings.count, &bindings.capacity, sizeof(Binding)) as *Binding) = binding
         return true
      }
   } else if pattern.kind == EXPR_FUN && value.kind == EXPR_FUN {
      if pattern.name == value.name && pattern.args_count == value.args_count {
         for let i = 0, i < pattern.args_count, i += 1 {
            if !pattern_match((pattern.args as *Expr)[i], (value.args as *Expr)[i], bindings) {
               return false
            }
         }
         return true
      }
   }
   return false
}

struct Rule {
   head Expr
   body Expr
}

assert COUNT_EXPRS == 2
fn rule_apply_all(rule Rule, expr Expr) Expr {
   let bindings Bindings
   bindings.data = 0 as *Binding
   bindings.count = 0
   bindings.capacity = 0

   if !pattern_match(rule.head, expr, &bindings) {
      match expr.kind {
         EXPR_SYM => return expr
         EXPR_FUN => {
            let new_fun = expr_fun(expr.name)
            for let i = 0, i < expr.args_count, i += 1 {
               &new_fun << rule_apply_all(rule, (expr.args as *Expr)[i])
            }
            return new_fun
         }
      }
   }

   return bindings_substitute(&bindings, rule.body)
}

fn [<<](file *File, rule Rule) *File {
   file << rule.head << " = " << rule.body
   return file
}

assert COUNT_EXPRS == 2
fn parse_expr(result *Expr) bool {
   let name Token
   if !lexer_expect(TOKEN_IDENT, &name) { return false }
   let peek_row bool
   if !lexer_peek_row(&lexer.buffer, &peek_row) { return false }
   if peek_row && lexer.buffer.kind == TOKEN_LPAREN {
      lexer.peeked = false

      let fun = expr_fun(name.str)
      let read bool
      if !lexer_read(TOKEN_RPAREN, &read) { return false }
      if !read {
         for true {
            let expr Expr
            if !parse_expr(&expr) { return false }
            &fun << expr
            let token Token
            if !lexer_either(TOKEN_COMMA, TOKEN_RPAREN, &token) { return false }
            if token.kind == TOKEN_RPAREN {
               break
            }
         }
      }
      *result = fun
      return true
   }
   *result = expr_sym(name.str)
   return true
}

fn parse_rule(result *Rule) bool {
   let rule Rule
   if !parse_expr(&rule.head) { return false }
   let eq_token Token
   if !lexer_expect(TOKEN_EQ, &eq_token) { return false }
   if !parse_expr(&rule.body) { return false }
   *result = rule
   return true
}

struct Named_Rule {
   name Str
   rule Rule
}

struct Context {
   rules *Named_Rule
   rules_count int
   rules_capacity int
   curr_expr Expr
   in_shape bool
}

fn context_new() Context {
   let context Context
   context.rules = 0 as *Named_Rule
   context.rules_count = 0
   context.rules_capacity = 0
   context.in_shape = false
   return context
}

fn context_rules_find(context *Context, name Str, rule *Rule) bool {
   for let i = 0, i < context.rules_count, i += 1 {
      if context.rules[i].name == name {
         *rule = context.rules[i].rule
         return true
      }
   }
   return false
}

fn context_rules_push(context *Context, name Str, rule Rule) {
   let named_rule Named_Rule
   named_rule.name = name
   named_rule.rule = rule
   *(array_push(&context.rules as **char, &context.rules_count, &context.rules_capacity, sizeof(Named_Rule)) as *Named_Rule) = named_rule
}

fn context_process_command(context *Context) bool {
   let token Token
   if !lexer_next(&token) { return false }

   match token.kind {
      TOKEN_RULE => {
         let name Token
         if !lexer_expect(TOKEN_IDENT, &name) { return false }
         let existing_rule Rule
         if context_rules_find(context, name.str, &existing_rule) {
            &stderr << name.pos << "error: redefinition of existing rule '" << name.str << "'\n"
            return false
         }
         let rule Rule
         if !parse_expr(&rule.head) { return false }
         let eq_token Token
         if !lexer_expect(TOKEN_EQ, &eq_token) { return false }
         if !parse_expr(&rule.body) { return false }
         &stdout << "defined rule " << rule << "\n"
         context_rules_push(context, name.str, rule)
      }
      TOKEN_SHAPE => {
         if context.in_shape {
            &stderr << "error: already shaping an expression\n"
            return false
         }
         let expr Expr
         if !parse_expr(&expr) { return false }
         &stdout << "shaping " << expr << "\n"
         context.curr_expr = expr
         context.in_shape = true
      }
      TOKEN_APPLY => {
         if !context.in_shape {
            &stdout << "error: no shaping in place\n"
            return false
         }
         let name Token
         if !lexer_expect(TOKEN_IDENT, &name) { return false }
         let rule Rule
         if context_rules_find(context, name.str, &rule) {
            let new_expr = rule_apply_all(rule, context.curr_expr)
            &stdout << new_expr << "\n"
            context.curr_expr = new_expr
         } else {
            &stderr << "error: rule '" << name.str << "' does not exist\n"
            return false
         }
      }
      TOKEN_DONE => {
         if !context.in_shape {
            &stdout << "error: no shaping in place\n"
            return false
         }
         &stdout << "finished shaping expression " << context.curr_expr << "\n"
         context.in_shape = false
      }
      else => {
         &stderr << token.pos << "error: expected keyword 'rule', 'shape', 'apply' or 'done', got " << str_from_token_kind(token.kind) << "\n"
         return false
      }
   }
   return true
}

fn read_line(fd int) Str {
   let buf = 0 as *char
   let buf_count = 0
   let buf_capacity = 0

   let ch char
   for true {
      if read(fd, &ch, 1) <= 0 {
         break
      }

      *array_push(&buf, &buf_count, &buf_capacity, sizeof(char)) = ch
      if ch == '\n' {
         break
      }
   }

   let str Str
   str.data = buf
   str.size = buf_count
   return str
}

fn main() {
   let context = context_new()
   for true {
      &stdout << "> "
      let line = read_line(STDIN)
      if line.size == 0 { break }
      if line.size > 1 {
         lexer_from_str(line, "<stdin>")
         context_process_command(&context)
      }
   }
}
